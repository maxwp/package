PHP 8.2 crazy performance benchmarks

@author Maxim Miroshnichenko <max@miroshnichenko.org>

==============================================================

PHP 8.2.28 (cli) (built: Mar 13 2025 18:21:38) (NTS)
Copyright (c) The PHP Group
Zend Engine v4.2.28, Copyright (c) Zend Technologies with Zend OPcache v8.2.28, Copyright (c), by Zend Technologies

opcache.enable_cli => Off => Off

AWS EC2 c6gn.xlarge

PRETTY_NAME="Debian GNU/Linux 12 (bookworm)"
NAME="Debian GNU/Linux"
VERSION_ID="12"
VERSION="12 (bookworm)"
VERSION_CODENAME=bookworm

==============================================================

Ключевое:
- локальные переменные быстрее свойств (0 ms vs 7 ms),
  свойства быстрее свойсв-массивов (7 ms vs 17 ms)
- собаки @ это пиздец, +17 ms минимум, запускают debug backtrace если даже ошибок нет
- иногда выгоднее копирнуть свойство или элемент массива в локальную переменную и дальше с ней работать,
  потому что доступ к локальной переменной 0 ms, а доступ к свойству всегда 7, а свойству-массива 17 ms.
  Это только доступ, то есть получение указателя на кусочек памяти.
  Если писать $this->array['key'] то всегда ищется array, затем в нем всегда ищется key.
  И если такого кода дофига - пиздец производительности, просто тратим силы на поиск переменных.
- foreach сильно быстрее for
- closure & lamda это ад

==============================================================

Время в ms для 1_000_000 итераций:
(сам цикл заниает 4 ms и эти 4 ms я удалил из теста, дальше только чистые данные)

==============================================================

Использование оператора подавления ошибок (@) резко замедляет код.
Дело в том, что PHP при этом всегда начинает собирать дополнительную информацию через debug backtrace, даже если ошибки нет.

==============================================================

// получение указателя (доступ к пременной)
$a; // 0 ms локальная переменная
@$a; // 17 ms если учесть что переменная на самом деле инициирована; собака добавляет +17 ms на ровно месте
@$a; // 230 ms если переменная не инициирована, вот так собаки портят жизнь
$this->_a; // 7 ms
@$this->_a; // 12 ms

$this->_a['key3']; // 17 ms
$this->_a['key1']['key2']; // 29 ms
$this->_a['key4']['key5']['key6']; // 41 ms
$this->_a;$this->_a;$this->_a; // 37 ms _a это массив
@$this->_a;@$this->_a;@$this->_a; // 45 ms _a это массив
$this->_b;$this->_b;$this->_b; // 20 ms _b это int/float/bool/string
@$this->_b;@$this->_b;@$this->_b; // 35 ms _b это int/float/bool/string

// это только поиск элемента по ключу, элемент существует
$this->_a['key1'];$this->_a['key2']; // 36 ms
$this->_a[1];$this->_a[2]; // 32 ms, числовые ключи чуть быстрее
$this->_b1;$this->_b2; // 13-14 ms (сходится с доступом к одному свойству)

// присвоение, $j динамически меняется
$this->_a['key'] = $j; // 19 ms
$this->_a = $j; // 7 ms
$a = $j; // 4 ms

// переприсванивание из свойства в локальльную переменную (дальше к ней доступ 0 ms будет)
$a = $this->_b1; // 8-9 ms, фактически сохранить себе указатель сильно дешевле

$this->_a = $a; // 5 ms, если массив инициирован заранее $a = [1,2,3]; - сильно дешевле вдуть его сразу
$this->_a[1] = $a[1];$this->_a[2] = $a[2];$this->_a[3] = $a[3]; // 68 ms пиздец долго, сплошные malloc

$this->_a = 1; // 6 ms
$this->_a = 1; $this->_a *= 1; // 19 ms

// статическое присвоение быстрее массивом
$this->_a['a'] = 1;$this->_a['b'] = 2;$this->_a['c'] = 3; // 61 ms
$this->_a = array( // 8 ms
    'a' => 1,
    'b' => 2,
    'c' => 3,
);

// но если массив надо собирать - жопа
$this->_a['a'] = $j;$this->_a['b'] = $j;$this->_a['c'] = $j; // 58 ms
$this->_a = array( // 67 ms
    'a' => $j,
    'b' => $j,
    'c' => $j,
);
// поэтому лучше ебнуть в свойства
$this->_a = $j;$this->_b = $j;$this->_с = $j; // 28 ms
// еще лучше конечно в локальны переменные
$a = $j; $b = $j; $c = $j; // 12 ms

// собирать статический массив лучше целиком сразу
$a = []; $a['key1'] = 1; $a['key2'] = 2; // 56 ms
$a = array( // 5 ms
    'key1' => 1,
    'key2' => 2,
);

// собирать массив выгоднее всего сразу и с числовыми ключами
$a = []; $a['key1'] = $j; $a['key2'] = $j; // 58 ms
$a = array( // 50 ms
    'key1' => $j,
    'key2' => $j,
);
$a = [$j, $j]; // 41 ms
= return [a, b] лучше не делать, лучше уже записать this->a, $this->b а потом их прочитать
= потому что собрать массив 50 ms, а сохранить в свойства 6+6=12 ms
= затем читать элементы из массива это 16+16= 32 ms, а из свойств 7+7 = 14 ms
= итого разница 50+32=82 vs 12+14=28, то есть x3 раза

// если массив $tmp инициирован заранее (динамический) $tmp = [$t, $t, $t]; то выгоднее его сразу присвоить
// чем переписывать по-элементно
// (скорее всего там срабатывает cow)
// поэтому если что-то вернуло массив - то лучше его сразу и сохранять
$this->_a = $tmp; // 8 ms
$this->_a[0] = $tmp[0]; // 76 ms
$this->_a[1] = $tmp[1];
$this->_a[2] = $tmp[2];

==============================================================

Втягивние переменных внутрь метода

1М вызовов метода:

// 16 ms call пустого метода
private function _test() {}

// 22 ms если внутри метода один раз достать $this->_x;
private function _test() {
    $this->_x;
}

// 89 ms если 10 раз достать $this->_x;
private function _test() {
    $this->_x;
    ...
    $this->_x; // 10 раз
}

// 24 ms если переписаь в локальную переменную $x и дальше 10-20-30 раз ее дернуть
private function _test() {
    $x = $this->_x;

    $x; $x; ... // сколько угодно раз
}

// 1151 ms для цикла с $this->_x
// но 2712 ms если $this->_x не была проиницирована, то есть просто private $_x; вместо private $_x = 1;
// надо быть супер аккуратным с инициацией
private function _test() {
    for ($i = 0; $i < 100; $i++) {
        if ($this->_x > $i) {

        }
    }
}

// 784 ms для цикла с локальным $x
// это доказывает что лучше втягивать в локальную переменную
// но 2054 ms если $this->_x не была проиницирована, то есть просто private $_x; вместо private $_x = 1;
// надо быть супер аккуратным с инициацией
private function _test() {
    $x = $this->_x;

    for ($i = 0; $i < 100; $i++) {
        if ($x > $i) {

        }
    }
}

// 1860 ms - какая-то жопа с указателями
private function _test() {
    $x = &$this->_x;

    for ($i = 0; $i < 100; $i++) {
        if ($x > $i) {

        }
    }
}

// 34 ms
private function _test() {
    $this->_x['key1'];
}

// 2318 ms
private function _test() {
    for ($i = 0; $i < 100; $i++) {
        if ($this->_x['key1'] > $i) {

        }
    }
}

// 800 ms, быстрее в 4 раза
// доступ по ключу массива это пиздец конечно
private function _test() {
    $x = $this->_x['key1'];

    for ($i = 0; $i < 100; $i++) {
        if ($x > $i) {

        }
    }
}

==============================================================

foreach vs for:

foreach быстрее for, $a это 100 элементов int 1
foreach ($a as $x) {} // 930 ms
foreach ($a as $index => $x) {} // 1244 ms, то есть лишний index это пиздец
for ($x = 0; $x < count($a); $x++) {} // 1009 ms, и при этом еще нет доступа к элементу массива
for ($x = 0; $x < count($a); $x++) {$a[$x];} // 1888 ms, это уже с доступом
for ($x = 0; $x < 100; $x++) {$a[$x];} // 1352 ms
$cnt = count($a);for ($x = 0; $x < $cnt; $x++) {$a[$x];} // 1363 ms, то есть count в цикле это пиздец
$cnt = count($a);for ($x = 0; $x < $cnt; $x++) {} // 455 ms, быстрее foreach, но без доступа к элементу

==============================================================

printы:

1M вызовов print '.';
это 1749 ms > file.log
это 400 ms > /dev/null
А если выводить в консоль stdout - еще больший пиздец

==============================================================

new ClassName медленнее чем создание [array]

// 9 ms, но это статический массив
$x = array(
    'a' => 1,
    'b' => 1,
);

// 50 ms, это динамический массив, его нельзя инлайнить
$a = array(
    'key1' => $j,
    'key2' => $j,
);

new TmpClass($j, $j) // 84 ms

class TmpClass {
    public function __construct($a, $b) {
        $this->a = $a;
        $this->b = $b;
    }

    public $a, $b;
}

// new stdClass медленее чем мой класс TmpClass, хотя это пиздец,
// сама суть stdClass по документациям в том чтобы сделать ультра-быструю структуру
// и это статический stdClass
$x = new stdClass(); // 93 ms
$x->a = 1;
$x->b = 1;

==============================================================

call:

просто вызов любого метода $this->_method1() // 16 ms
если передать параметры $this->_method1($j) // 18 ms
каждый следующий параметр +2 ms
и это метод еще нихера не делает внутри, просто пустой

==============================================================

closure & lambda:

interface IReceiver {
    public function run($ts, $j);
}
class Receiver implements IReceiver {
    public function run($ts, $j) {}
}

    private function _run1($ts, callable $f) {
        for ($j = 1; $j <= 1_000_000; $j++) {
            $f($ts, $j);
        }
    }

    private function _run2($ts, IReceiver $receiver) {
        for ($j = 1; $j <= 1_000_000; $j++) {
            $receiver->run($ts, $j);
        }
    }

    private function _run3($ts) {
        for ($j = 1; $j <= 1_000_000; $j++) {
            $this->_receiver->run($ts, $j);
        }
    }

    private function _run4($ts) {
        $receiver = $this->_receiver;
        for ($j = 1; $j <= 1_000_000; $j++) {
            $receiver->run($ts, $j);
        }
    }

    // ниже числа где 1 раз вызывается _runX
    // closure тяжело передается, а use +1 параметр добавляет +6 ms на один вызов, не на 1М вызовов
    $this->_run1($t, function($ts, $j) {}); // 38 ms - for 4 ms = 34 ms
    $this->_run1($t, function($ts, $j) use ($t) {}); // 44 ms - 4 = 40 ms
    $this->_run1($t, $fn); // 38 ms -4 = 34 ms
    $this->_run2($t, $receiver); // 31 - 4 = 27 ms << самый быстрый способ это передать receiver 1 раз, он станет локальным в методе
    $this->_run3($t); // 36 ms - 4 = 32 ms (дерганье объекта хуевое)
    $this->_run4($t); // 31 ms - 4 = 27 ms << тоже самый лучший варант

Другой тест: если 1М раз вызывать run, каждый раз передавая callback в виде function или receiver
    $this->_run(array($this, '_callback1')); // 280 ms
    $this->_run(function ($ts, $x) {}); // 214 ms, чуть быстрее
    $this->_run($receiver); // 125 ms объект с invoke
    $this->_run($receiver); // 111 ms без invoke, разница в 2.5 раз

Итого: closure как-то херово инлайнится внутрь, лучше от него избавляться.
А lamda-use вообще шляпа.
Правда вот современные либы типа Rachet/react все на этой блямбда-хуйне.

==============================================================

strings concatenations:

самые большие проблемы это автоприведение типов, на втором месте конкатенация.

$s = $int.$int.$int; // 139 ms
$s = "$int$int$int"; // 117 ms << лучше всего сразу в одну строку
$s = $int; $int .= $int; $s .= $int; // 143 ms, клеить заметно хуже

// если $a и $b string - то значения не имеет как склеивать
$s = $a.$b; // 27 ms
$s = "$a$b"; // 28 ms
$s = $a; $s .= $b; // 40 ms, клеить по очереди всегда пиздец

// но для длинных строк - все равно выгодно клеить в одну строку
$s = $a.$b.$a.$b.$a.$b.$a.$b.$a.$b.$a.$b; // 192..194 ms
$s = "$a$b$a$b$a$b$a$b$a$b$a$b"; // 139..140 ms << самый выгодный вариант
$s = "{$a}{$b}{$a}{$b}{$a}{$b}{$a}{$b}{$a}{$b}{$a}{$b}"; // 139..140 ms, нифига не меняется
$s = $a; $s .= $b, ... и так дофига раз // 700+ ms, пиздец вам всем, так делать не надо

Это все обясняется бесконечным memory alloc и перекладываем переменных из памяти в память в новую бОльшую ячейку.

==============================================================

ifы:
и это йибать странно, у меня нет объяснений

// быстрее прыгнуть в if чем за него, это заставляет писать if (true) {} else { logic here } если нужно false
if (true) {} // 1.28 ms
if (false) {} // 2.84 ms

// для int проблем нет, хотя они и медленее :)
if (1) {} // 4.45 ms
if (0) {} // 4.73 ms

Upd: Неожиданное поведение связано с предсказанием переходов процессора и внутренней реализацией PHP: пустой true быстрее пустого false.
Если много пустых условий (встречается редко), убедись, что горячие пути чаще истинны (branch prediction friendly).

==============================================================

consts:

if (defined('myconst')) {} // 3.9 ms если false, 1.27 ms если true. Что тоже пиздец как логично ж
if ($this->_boolVar) {} // 4.88 ms

==============================================================

fill массивов:

for ($j = 0; $j < 1_000_000; ++$j) {
    $this->_test();
}

// 1098 ms
private function _test() {
    $x = rand(1, 100);
    $a = [];
    for ($i = 1; $i <= $x; $i++) {
        $a[$i] = $i;
    }
}

// 930 ms - без индекса быстрее на 10%
private function _test() {
    $x = rand(1, 100);
    $a = [];
    for ($i = 1; $i <= $x; $i++) {
        $a[] = $i;
    }
}

// 1010 ms, если массив уже заполнен и я его копирую - трохи быстрее
private $_bucket = array_fill(0, 100, 0);
private function _test() {
    $x = rand(1, 100);
    $a = $this->_bucket;
    for ($i = 1; $i <= $x; $i++) {
        $a[$i] = $i;
    }
}

// 865 ms, тоже самое, только bucket по указателю
// это странно конечно, работает только с массивами, с обычными переменными делает сильно хуже
// надо быть аккуратным, по перетирарается сам $this->_bucket
private $_bucket = array_fill(0, 100, 0);
private function _test() {
    $x = rand(1, 100);
    $a = &$this->_bucket;
    for ($i = 1; $i <= $x; $i++) {
        $a[$i] = $i;
    }
}

// 1180 ms, то то есть вызов $this->xxx пиздец тяжелый
private $_bucket = array_fill(0, 100, 0);
private function _test() {
    $x = rand(1, 100);
    for ($i = 1; $i <= $x; $i++) {
        $this->_bucket[$i] = $i;
    }
}

==============================================================

ini_set('zend.enable_gc', 0);

Убирает запуск garbage collector, все становится чуть сложнее, но циклы стабильне.

==============================================================

OPCACHE + JIT

NB! шо opcache+jit это жопа с eval, если есть eval smarty - всему пизда сразу же

Синтетический тест на вызовы методов и доступ к свойствам:
php -f 1.php // 791 ms
php -d opcache.enable=1 -d opcache.validate_timestamps=1 -d opcache.revalidate_freq=0 -d opcache.enable_cli=1 -f 1.php // 642 ms opcache only
php -d opcache.enable=1 -d opcache.validate_timestamps=1 -d opcache.revalidate_freq=0 -d opcache.enable_cli=1 -d opcache.jit_buffer_size=100M -d opcache.jit=function -f  1.php // 244 ms
php -d opcache.enable=1 -d opcache.validate_timestamps=1 -d opcache.revalidate_freq=0 -d opcache.enable_cli=1 -d opcache.jit_buffer_size=100M -d opcache.jit=tracing -f  1.php // 114 ms

c6gn.large
php 789 ms
php +opcache 641 ms
php +opcache +jit 114 ms
php +compiled 8.2.28 - 790 ms
php +compiled +opcache - 638 ms
php +compiled +opcache + jit 114 ms
= сборка php -O3 native не помогает

c6a.large (amd)
php 527 ms
php +opcache 607 ms, странно делает хуже
php +opcache +jit 65 ms << best of
php +compiled
php +compiled +opcache
php +compiled +opcache + jit
amd сеть в 3.5 раза хуже c6gn (тест udp loopback)

c6i.large (intel)
php 522 ms
php +opcache 396 ms
php +opcache +jit 90 ms
php +compiled
php +compiled +opcache
php +compiled +opcache + jit
intel сеть хуже в 1.5 раза (тест udp loopback)

@todo metal, в тч a1.metal (без контекст свитчинга)
@todo php 8.2 vs 8.3 vs 8.4
